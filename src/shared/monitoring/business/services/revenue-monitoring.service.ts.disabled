/**
 * Revenue Monitoring Service - Following SOLID Principles
 *
 * Single Responsibility: Only handles revenue monitoring calculations
 * Open/Closed: Open for extension with new revenue metrics
 * Interface Segregation: Implements focused revenue monitoring interface
 * Dependency Inversion: Depends on abstractions, not concrete implementations
 * Liskov Substitution: Simple, focused implementation
 *
 * KISS Principle: Simple, clear revenue monitoring calculations
 * No unnecessary complexity, focused on revenue analysis
 */

import { Injectable } from '@nestjs/common';
import { IRevenueMonitoringService } from '../interfaces/business-metric-services.interface';
import {
  MetricTimeRange,
  RevenueMetrics,
  BusinessMetric,
  MetricType,
  MetricUnit
} from '../types/metric.types';

@Injectable()
export class RevenueMonitoringService implements IRevenueMonitoringService {
  /**
   * Calculate total revenue for the time range
   * Single Responsibility: Only handles total revenue calculations
   * KISS: Simple revenue aggregation
   */
  async getTotalRevenue(timeRange: MetricTimeRange): Promise<RevenueMetrics> {
    const totalRevenue = await this.calculateTotalRevenue(timeRange);
    const growthRate = await this.calculateGrowthRate(timeRange);
    const recurringRevenue = await this.calculateRecurringRevenue(timeRange);
    // const revenueByCategory = await this.calculateRevenueByCategory(timeRange); // Temporarily disabled
    const revenueByRegion = await this.calculateRevenueByRegion(timeRange);
    const avgRevenuePerUser = await this.calculateAverageRevenuePerUser(timeRange);

    return {
      totalRevenue: this.createMetric(
        'total-revenue',
        'Total Revenue',
        'Total revenue generated in the specified time range',
        MetricType.REVENUE,
        totalRevenue,
        MetricUnit.CURRENCY,
        timeRange
      ),
      revenueGrowthRate: this.createMetric(
        'revenue-growth-rate',
        'Revenue Growth Rate',
        'Percentage change in revenue compared to previous period',
        MetricType.REVENUE,
        growthRate,
        MetricUnit.PERCENTAGE,
        timeRange
      ),
      recurringRevenue: this.createMetric(
        'recurring-revenue',
        'Recurring Revenue',
        'Revenue from recurring sources (subscriptions, contracts)',
        MetricType.REVENUE,
        recurringRevenue,
        MetricUnit.CURRENCY,
        timeRange
      ),
      revenueByProductCategory: [], // Placeholder for now
      revenueByRegion,
      averageRevenuePerUser: this.createMetric(
        'average-revenue-per-user',
        'Average Revenue Per User',
        'Average revenue generated per active user',
        MetricType.REVENUE,
        avgRevenuePerUser,
        MetricUnit.CURRENCY,
        timeRange
      )
    };
  }

  /**
   * Calculate revenue growth rate
   * Single Responsibility: Only handles growth rate calculations
   * KISS: Simple percentage calculation
   */
  async getRevenueGrowthRate(timeRange: MetricTimeRange): Promise<RevenueMetrics> {
    return this.getTotalRevenue(timeRange);
  }

  /**
   * Calculate revenue by product category
   * Single Responsibility: Only handles category-based revenue calculations
   * KISS: Simple category aggregation
   */
  async getRevenueByProductCategory(timeRange: MetricTimeRange): Promise<RevenueMetrics> {
    return this.getTotalRevenue(timeRange);
  }

  /**
   * Calculate recurring revenue metrics
   * Single Responsibility: Only handles recurring revenue calculations
   * KISS: Simple recurring revenue calculation
   */
  async getRecurringRevenueMetrics(timeRange: MetricTimeRange): Promise<RevenueMetrics> {
    return this.getTotalRevenue(timeRange);
  }

  /**
   * Calculate total revenue - KISS: Simple calculation
   * Single Responsibility: Only handles revenue calculation
   */
  private async calculateTotalRevenue(timeRange: MetricTimeRange): Promise<number> {
    // Simulate calculation - in real implementation, this would query financial data
    const daysInRange = Math.ceil((timeRange.endDate.getTime() - timeRange.startDate.getTime()) / (1000 * 60 * 60 * 24));
    const baseDailyRevenue = 5000.00; // Base daily revenue
    const growthRate = 0.03; // 3% daily growth
    const seasonalVariation = Math.sin((timeRange.startDate.getMonth() / 12) * Math.PI * 2) * 0.1; // Seasonal variation

    let totalRevenue = 0;
    for (let i = 0; i < daysInRange; i++) {
      const dayRevenue = baseDailyRevenue * Math.pow(1 + growthRate, i) * (1 + seasonalVariation);
      totalRevenue += dayRevenue;
    }

    return Math.round(totalRevenue * 100) / 100; // Round to 2 decimal places
  }

  /**
   * Calculate growth rate - KISS: Simple percentage calculation
   * Single Responsibility: Only handles growth rate calculation
   */
  private async calculateGrowthRate(_timeRange: MetricTimeRange): Promise<number> {
    // Simulate calculation - in real implementation, this would compare with previous period
    const baseGrowthRate = 0.15; // 15% base growth rate
    const variation = (Math.random() - 0.5) * 0.05; // ±2.5% variation

    return Math.round((baseGrowthRate + variation) * 10000) / 100; // Round to 2 decimal places
  }

  /**
   * Calculate recurring revenue - KISS: Simple calculation
   * Single Responsibility: Only handles recurring revenue calculation
   */
  private async calculateRecurringRevenue(timeRange: MetricTimeRange): Promise<number> {
    const totalRevenue = await this.calculateTotalRevenue(timeRange);
    const recurringRevenuePercentage = 0.65; // 65% of revenue is recurring
    const variation = (Math.random() - 0.5) * 0.1; // ±5% variation

    return Math.round(totalRevenue * (recurringRevenuePercentage + variation) * 100) / 100;
  }

  /**
   * Calculate revenue by product category - KISS: Simple calculation
   * Single Responsibility: Only handles category revenue calculation
   */
  // private async calculateRevenueByCategory(_timeRange: MetricTimeRange): Promise<BusinessMetric[]> {
  // const categories = [
  //   { name: 'Software Licenses', percentage: 0.35 },
  //   { name: 'Professional Services', percentage: 0.25 },
  //   { name: 'Support & Maintenance', percentage: 0.20 },
  //   { name: 'Training', percentage: 0.10 },
  //   { name: 'Other', percentage: 0.10 }
  // ];

  // const totalRevenue = await this.calculateTotalRevenue(timeRange);
  // const categoryMetrics: BusinessMetric[] = [];

  // for (const category of categories) {
  //   const categoryRevenue = totalRevenue * category.percentage * (1 + (Math.random() - 0.5) * 0.1);

  //   categoryMetrics.push(this.createMetric(
  //     `revenue-${category.name.toLowerCase().replace(' ', '-')}`,
  //     `Revenue - ${category.name}`,
  //     `Revenue from ${category.name} category`,
  //     MetricType.REVENUE,
  //     Math.round(categoryRevenue * 100) / 100,
  //     MetricUnit.CURRENCY,
  //     timeRange,
  //     { category: category.name, percentage: category.percentage }
  //   ));
  // }

  // return categoryMetrics;
  }

  /**
   * Calculate revenue by region - KISS: Simple calculation
   * Single Responsibility: Only handles regional revenue calculation
   */
  private async calculateRevenueByRegion(timeRange: MetricTimeRange): Promise<BusinessMetric[]> {
    const regions = [
      { name: 'North America', percentage: 0.45 },
      { name: 'Europe', percentage: 0.30 },
      { name: 'Asia Pacific', percentage: 0.15 },
      { name: 'Other', percentage: 0.10 }
    ];

    const totalRevenue = await this.calculateTotalRevenue(timeRange);
    const regionMetrics: BusinessMetric[] = [];

    for (const region of regions) {
      const regionRevenue = totalRevenue * region.percentage * (1 + (Math.random() - 0.5) * 0.1);

      regionMetrics.push(this.createMetric(
        `revenue-${region.name.toLowerCase().replace(' ', '-')}`,
        `Revenue - ${region.name}`,
        `Revenue from ${region.name} region`,
        MetricType.REVENUE,
        Math.round(regionRevenue * 100) / 100,
        MetricUnit.CURRENCY,
        timeRange,
        { region: region.name, percentage: region.percentage }
      ));
    }

    return regionMetrics;
  }

  /**
   * Calculate average revenue per user - KISS: Simple calculation
   * Single Responsibility: Only handles ARPU calculation
   */
  private async calculateAverageRevenuePerUser(timeRange: MetricTimeRange): Promise<number> {
    const totalRevenue = await this.calculateTotalRevenue(timeRange);
    const daysInRange = Math.ceil((timeRange.endDate.getTime() - timeRange.startDate.getTime()) / (1000 * 60 * 60 * 24));

    // Simulate active users - in real implementation, this would query user analytics
    const activeUsers = 100 * Math.pow(1.05, daysInRange); // 5% daily growth

    return Math.round((totalRevenue / activeUsers) * 100) / 100; // Round to 2 decimal places
  }

  /**
   * Create a business metric object - KISS: Simple factory method
   * Single Responsibility: Only handles metric object creation
   */
  private createMetric(
    id: string,
    name: string,
    description: string,
    type: MetricType,
    value: number,
    unit: MetricUnit,
    timeRange: MetricTimeRange,
    metadata?: Record<string, unknown>
  ): BusinessMetric {
    return {
      id,
      name,
      description,
      type,
      value: {
        value,
        unit,
        formatted: this.formatValue(value, unit)
      },
      timeRange,
      calculatedAt: new Date(),
      metadata
    };
  }

  /**
   * Format metric values for display - KISS: Simple formatting logic
   * Single Responsibility: Only handles value formatting
   */
  private formatValue(value: number, unit: MetricUnit): string {
    switch (unit) {
      case MetricUnit.CURRENCY:
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD'
        }).format(value);

      case MetricUnit.PERCENTAGE:
        return `${value.toFixed(2)}%`;

      case MetricUnit.COUNT:
        return Math.round(value).toLocaleString();

      case MetricUnit.TIME:
        if (value < 60) {
          return `${value.toFixed(1)}s`;
        } else if (value < 3600) {
          return `${(value / 60).toFixed(1)}m`;
        } else {
          return `${(value / 3600).toFixed(1)}h`;
        }

      case MetricUnit.RATIO:
        return value.toFixed(2);

      case MetricUnit.RATE:
        return `${value.toFixed(2)}/day`;

      default:
        return value.toString();
    }
  }
}